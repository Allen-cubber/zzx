---
title: FFT算法
date: 2025-12-19T08:00:00+08:00
tags:
  - 大三上
  - 数字信号处理
summary: 在本讲中，我们将深入学习如何优化离散傅里叶变换（DFT）的计算效率，掌握快速傅里叶变换（FFT）的核心原理与实现。
---
# 📝 数字信号处理笔记：第16讲 —— 快速DFT算法 (FFT)

在本讲中，我们将深入学习如何优化离散傅里叶变换（DFT）的计算效率，掌握<font color="orange">快速傅里叶变换</font>（FFT）的核心原理与实现。

---

## 1. 为什么要引入 FFT？ 🤔

离散傅里叶变换（DFT）和逆离散傅里叶变换（IDFT）的定义公式如下：

$$\boxed{X(k) = \sum_{n=0}^{N-1} x[n] W_N^{kn}, \quad 0 \leq k \leq N-1}$$
$$\boxed{x[n] = \frac{1}{N} \sum_{k=0}^{N-1} X(k) W_N^{-kn}, \quad 0 \leq n \leq N-1}$$

其中旋转因子 $\boxed{W_N = e^{-j\frac{2\pi}{N}}}$。

### 📉 DFT 的运算量分析
对于一个 $N$ 点的 DFT：
*   **复数乘法次数**：$N \times N = \boxed{N^2}$
*   **复数加法次数**：$N \times (N-1) \approx \boxed{N^2}$

**计算瓶颈示例**：
在计算机诞生初期，计算一个 $1024$ 点的 DFT 约需要 $1$ 小时。若处理一幅 $1024 \times 1024$ 的卫星图片：
*   分行分列处理需要 $42$ 天。
*   一次性处理 $100$ 万个点则需要**上百年**。

为了缩短计算时间，我们需要从**硬件**（提高运算速度）和**软件**（减少计算次数）两方面入手。FFT 正是软件层面的重大优化。🚀

---

## 2. 算法优化的核心原理 💡

FFT 算法通过利用旋转因子 $W_N^{kn}$ 的特性来减少重复计算：

1.  **对称性**：$\boxed{W_N^{k+N/2} = -W_N^k}$
2.  **周期性**：$\boxed{W_N^{k+lN} = W_N^k}$
3.  **特殊值**：$\boxed{W_N^{N/2} = -1}$

此外，利用乘法的**结合律**（合并同类项）可以将多次乘法简化：
$$\boxed{ab + ac = a(b+c)}$$
这样就将“两次乘法+一次加法”优化为了“一次加法+一次乘法”。

---

## 3. 基-2 FFT 算法分类 🧬

根据分解方式的不同，最基本的 FFT 算法分为两种：
1.  <font color="orange">按时间抽取</font>（DIT, Decimation in Time）
2.  <font color="orange">按频率抽取</font>（DIF, Decimation in Frequency）

---

## 4. 按时间抽取 FFT (DIT-FFT) ⏳

### 4.1 算法推导
将 $N$ 点序列 $x[n]$ 按序号的**奇偶**分为两组：
*   偶数点：$x_1[r] = x[2r]$
*   奇数点：$x_2[r] = x[2r+1]$

通过推导，得到 $N$ 点 DFT 与两个 $N/2$ 点 DFT 的关系式：
$$\boxed{X(k) = X_1[k] + W_N^k X_2[k]}$$
$$\boxed{X(k + N/2) = X_1[k] - W_N^k X_2[k]}$$
（其中 $0 \leq k \leq N/2-1$）

### 4.2 <font color="orange">蝶形运算</font>单元
这是 FFT 的最小计算单元。每进行一次蝶形运算，包含：
*   $1$ 次复数乘法
*   $2$ 次复数加法

### 4.3 运算流图特点（以 $N=8$ 为例）
*   **分解层数**：$L = \boxed{\log_2 N}$ 层（对于 $8$ 点，需分解 $3$ 层）。
*   **每层蝶形数**：每层有 $N/2$ 个蝶形。
*   **蝶形跨距**：随层数增加逐渐变大。
*   <font color="orange">无需额外存储空间</font>：采用原地运算。

### 4.4 <font color="orange">比特逆序</font> (Bit-reversal)
在 DIT-FFT 中，输入序列 $x[n]$ 的顺序需要打乱，而输出频谱 $X(k)$ 是正常顺序。
**规律**：将下标 $n$ 写成二进制，再将其**倒读**，即得到抽取的顺序。

| 初始顺序 (n) | 二进制 | 码位倒读 | 抽取顺序 (输出) |
| :--- | :--- | :--- | :--- |
| 0 | 000 | 000 | **0** |
| 1 | 001 | 100 | **4** |
| 2 | 010 | 010 | **2** |
| 3 | 011 | 110 | **6** |

---

## 5. 按频率抽取 FFT (DIF-FFT) 📻

### 5.1 算法推导
将输出序列 $X(k)$ 按**奇偶**划分。它将输入序列 $x[n]$ 分为前后两半：
$$\boxed{X[2r] = \sum_{n=0}^{N/2-1} [x(n) + x(n+N/2)] W_{N/2}^{nr}}$$
$$\boxed{X[2r+1] = \sum_{n=0}^{N/2-1} [x(n) - x(n+N/2)] W_N^n W_{N/2}^{nr}}$$

### 5.2 运算特点
*   **蝶形单元**：先做加减法，再做乘法（与 DIT 相反）。
*   **跨距变化**：蝶形跨距随层数增加<font color="orange">逐渐变小</font>。
*   **时序特点**：输入序列 $x[n]$ 为正常顺序，输出频谱 $X(k)$ 为<font color="orange">比特逆序</font>。

---

## 6. 运算量对比 📊

下表对比了 $N$ 点 DFT 与 FFT 的复数运算量：

| 算法 | 复数乘法次数 | 复数加法次数 |
| :--- | :--- | :--- |
| **DFT** | $N^2$ | $N(N-1)$ |
| **FFT** | $\boxed{\frac{N}{2} \log_2 N}$ | $\boxed{N \log_2 N}$ |

**改善比示例 ($N=1024$)**：
*   乘法速度提升约 **195 倍**！🚀
*   加法速度提升约 **100 倍**！

---

## 💡 注意点与易错点

1.  **输入输出顺序**：
    *   **DIT** (时间抽取)：时域序列打乱 (比特逆序)，频域正常。
    *   **DIF** (频率抽取)：时域序列正常，频域打乱 (比特逆序)。
2.  **原地运算**：FFT 在计算过程中不需要开辟额外的巨大数组，计算后的结果直接覆盖原有的存储单元。
3.  **计算条件**：本课件讨论的是基-2 FFT，要求 $N$ 必须是 $2$ 的整数次幂 ($N=2^L$)。如果点数不够，通常需要<font color="orange">补零</font>。

---

## 📝 本章学习总结

1.  **核心思想**：利用 $W_N^{kn}$ 的**对称性**、**周期性**，通过“分而治之”的策略，将长序列 DFT 分解为短序列 DFT。
2.  **两大流派**：
    *   **DIT**：按时间（输入）奇偶分解，蝶形由小变大。
    *   **DIF**：按频率（输出）奇偶划分，蝶形由大变小。
3.  **主要贡献**：FFT 极大地降低了运算复杂度，从 $O(N^2)$ 降至 $O(N \log_2 N)$，使实时数字信号处理成为可能。
4.  **关键步骤**：理解比特逆序的产生、蝶形运算的结构以及多层分解的流图规律。