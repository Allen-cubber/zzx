---
title: 第二章EDA开发硬件与软件平台
date: 2025-09-06T11:00:00+08:00
tags:
  - 大三上
  - 数字系统设计
summary: 本章我们将深入探讨EDA（电子设计自动化）开发所依赖的两大基石：硬件平台与软件平台。
---
本章我们将深入探讨EDA（电子设计自动化）开发所依赖的两大基石：<font color="orange">硬件平台</font>与<font color="orange">软件平台</font>。

-   **硬件平台 ⚙️**：主要指 Altera (现为Intel PSG) 的可编程逻辑器件 (PLD)。
-   **软件平台 💻**：主要指 Altera 的 Quartus II 开发软件。

---

## 第一部分：EDA 开发硬件平台 (可编程逻辑器件)

### 1. PLD 简介与发展

<font color="orange">可编程逻辑器件 (PLD)</font> 是一种允许用户根据自身需求配置其内部逻辑功能的半导体器件。它的发展极大地改变了数字电路的设计方式。

-   **设计的演进** 🚀：
    -   **早期**：使用分立的集成电路（如74系列芯片）在电路板上手动搭建，功能简单，体积庞大。
    -   **现在**：基于 <font color="orange">SOPC (System On a Programmable Chip)</font> 理念，可以在一片PLD芯片上集成一个高性能的CPU核心（如Nios II + ARM），实现复杂的片上系统。

#### 1.1 PLD 的发展历程 📈

PLD的发展趋势是朝着**超高速、高密度、低功耗、低电压**的方向前进。

-   **技术演进路线**：
    1.  `PLA` ➡️ `PAL` ➡️ `GAL` ➡️ `EPLD` ➡️ **CPLD**
    2.  `PLA` ➡️ `PAL` ➡️ `GAL` ➡️ **FPGA**

-   **发展时间轴**：

| 年代        | 公司      | 产品   | 代表特点                    |
| :-------- | :------ | :--- | :---------------------- |
| 20世纪70年代  | *       | PLA  | 熔丝编程                    |
| 20世纪70年代末 | AMD     | PAL  | 基于CMOS技术                |
| 20世纪80年代初 | Lattice | GAL  | 可重复编程                   |
| 20世纪80年代中 | Xilinx  | FPGA | **查找表 (LUT) 技术**        |
| 20世纪80年代中 | Altera  | EPLD | 电可擦除                    |
| 20世纪80年代末 | Lattice | CPLD | 同期出现**ISP (在系统可编程) 技术** |

#### 1.2 主流 PLD 生产厂商

-   **Altera (Intel)**: 全球最大的PLD供应商之一。
-   **Xilinx (AMD)**: FPGA 的发明者，也是全球最大的PLD供应商之一。
-   **Lattice**: ISP 技术的发明者。
-   **Actel (Microsemi)**: 提供军品及宇航级产品。

#### 1.3 两大厂商产品对比 (Altera vs. Xilinx)

| 厂商 | FPGA 产品系列 | CPLD 产品系列 (工艺) |
| :--- | :--- | :--- |
| **Altera** | Cyclone, Stratix 等 | MAX7000, MAX3000 (EEPROM) |
| **Xilinx** | Spartan, Virtex 等 | XC9500 (Flash) |

-   **性能对比**：
    -   <font color="orange">低端市场</font>：Altera 的 Cyclone 系列性能优于 Xilinx 的 Spartan 系列。
    -   <font color="orange">高端市场</font>：Xilinx 的 Virtex 系列性能优于 Altera 的 Stratix 系列。

---

### 2. PLD 的分类

PLD主要根据其内部实现逻辑的结构分为两大类：

1.  **基于<font color="orange">乘积项 (Product-term)</font>技术的PLD**：典型代表是 **CPLD**。
    -   其核心是“与-或”阵列结构。根据与阵列和或阵列是否可编程，又可细分。
2.  **基于<font color="orange">查找表 (Look-Up Table, LUT)</font>技术的PLD**：典型代表是 **FPGA**。
    -   其核心是基于SRAM的查找表结构。

#### 2.1 基于乘积项技术的 CPLD

##### ① 与阵列固定，或阵列可编程 (PROM)

-   **代表器件**：PROM (可编程只读存储器)。
-   **结构**：输入信号经过一个固定的“与”阵列（全译码），然后连接到一个可编程的“或”阵列。
-   **缺点**：随着输入信号数量增加，芯片面积会急剧增大，利用率和速度会降低。
-   **示例**：用PROM实现半加器。
    -   输入：$A_1, A_0$
    -   输出：$F_1$ (进位), $F_0$ (和)
    -   逻辑表达式：
        $F_0 = \overline{A_1}A_0 + A_1\overline{A_0}$
        $F_1 = A_1A_0$

##### ② 与阵列、或阵列均可编程 (PLA)

-   **代表器件**：PLA (可编程逻辑阵列)。
-   **结构**：与阵列和或阵列都可编程，灵活性最高。
-   **优点**：只需形成实际需要的乘积项，而不是全部最小项，因此比PROM更节省芯片面积，利用率更高。

##### ③ 与阵列可编程，或阵列固定 (PAL/GAL)

-   **代表器件**：PAL (可编程阵列逻辑), GAL (通用阵列逻辑)。
-   **结构**：与阵列可编程，但或阵列是固定的，每个输出宏单元连接固定数量的乘积项。

##### CPLD 内部结构详解 🔬

CPLD由多个逻辑阵列块（LAB）通过可编程连线（PIA）连接而成。

1.  **<font color="orange">宏单元 (Macrocell)</font>**：
    -   CPLD 的基本逻辑单元，用于实现基本的组合逻辑和时序逻辑。
    -   **左侧**：是乘积项阵列（一个“与-或”阵列），实现组合逻辑。
    -   **右侧**：是一个可编程的D触发器，实现时序逻辑。触发器可以被旁路，信号直接输出。
2.  **<font color="orange">可编程连线 (PIA - Programmable Interconnect Array)</font>**：
    -   负责在各个宏单元之间传递信号，连接所有的宏单元。
3.  **<font color="orange">I/O控制块</font>**：
    -   负责控制输入输出引脚的电气特性（如三态输出、摆率控制等）。
    -   处理全局信号，如全局时钟、全局清零等，确保这些信号到达每个宏单元的延时最短且相同。

#### 2.2 基于查找表技术的 FPGA

-   **核心单元**：<font color="orange">查找表 (Look-Up Table, LUT)</font>。
-   **工作原理**：LUT 本质上是一个小容量的RAM。逻辑运算的过程，就是将输入信号作为RAM的地址线，在预先存好逻辑运算结果的RAM中查找对应地址的内容，并将其输出。
    -   例如，一个4输入的LUT可以看作是一个有4位地址线（$2^4=16$）的 $16 \times 1$ 的RAM。
-   **实现流程**：`输入内容` ➡️ `转换地址` ➡️ `寻址查表` ➡️ `结果输出`

##### FPGA 内部结构详解 (以 FLEX10K 为例) 🏗️

FPGA 内部就像一个城市，由许多功能建筑（逻辑单元）和四通八达的交通网络（布线资源）构成。

1.  **<font color="orange">逻辑单元 (LE - Logic Element)</font>**：
    -   FPGA 实现逻辑功能的最基本单位。
    -   包含一个4输入LUT、一个可编程寄存器（D触发器）、进位链和级联链逻辑。
2.  **<font color="orange">逻辑阵列块 (LAB - Logic Array Block)</font>**：
    -   由多个（如8个）LE组成的一个功能群组。
3.  **<font color="orange">IO单元 (IOE - I/O Element)</font>**：
    -   位于芯片边缘，负责芯片内部逻辑与外部引脚之间的信号交互。
4.  **<font color="orange">布线资源 (Interconnects)</font>**：
    -   连接所有LE、LAB和IOE的“电线”，如快速通道互连 (FastTrack)。

---

### 3. CPLD 与 FPGA 的核心对比

这是一个非常重要的知识点，也是器件选型时的关键依据。

| 对比项 | CPLD | FPGA |
| :--- | :--- | :--- |
| **内部结构** | 基于 **Product-term** (乘积项) | 基于 **Look-up Table** (查找表) |
| **程序存储** | 内部 **EEPROM** / **Flash** (非易失性) | 内部 **SRAM** (易失性)，需外挂EEPROM |
| **资源类型** | 组合电路资源丰富 | 触发器资源丰富 |
| **集成度** | 低 | 高 |
| **使用场合** | 适合完成复杂的**控制逻辑** | 适合完成复杂的**算法**和**数据处理** |
| **速度** | 相对慢 | 相对快 |
| **其他资源** | 较少 | 丰富，如EAB(嵌入式阵列块)、锁相环(PLL) |
| **保密性** | 可加密 (配置信息固化在片内) | 一般不能保密 (每次上电需重新配置) |

🚨 **易错点提醒**：
CPLD是<font color="orange">非易失性</font>的，上电即工作，无需外部配置芯片。而FPGA是<font color="orange">易失性</font>的，每次上电都需要从外部的配置芯片（如Flash）加载程序。

---

### 4. FPGA/CPLD 相对于 MCU 的优势

MCU（微控制器，如单片机）是按顺序执行指令的，而FPGA/CPLD是硬件并行的。

1.  **并行编程，运行速度快** ⚡️：
    -   FPGA可以同时执行多个任务。例如，驱动VGA显示的同时，可以并行处理键盘输入和数据运算，而MCU则需要通过中断或分时处理，效率较低。
2.  **定制设计，灵活性高** 🎨：
    -   可以根据需求定制任意位宽的数据总线、任意数量的串口、PWM输出等。MCU的硬件资源（如串口数量、定时器个数）是固定的。
    -   **示例**：接收一幅 $640 \times 480$ 的图像。
        -   高端32位MCU所需时钟周期：$640 \times 480 / 32 = 9600$
        -   FPGA定制128位总线所需时钟周期：$\boxed{640 \times 480 / 128 = 2400}$，效率提升4倍。
3.  **集成锁相环(PLL), 倍频频率高** 🔄。
4.  **IO管脚多, 容易实现大规模系统** 🔌。
5.  **大量IP软核, 方便二次开发** 🧩。
6.  **物理机制纯硬件, 抗干扰能力强** 🛡️。

---

### 5. FPGA 的发展趋势

1.  **<font color="orange">IP核 (Intellectual Property core) 扩充</font>**：
    -   设计者可以直接调用成熟的、预先验证好的功能模块（IP核），如PCIe接口、以太网MAC、DDR控制器等，从而加速开发进程。
2.  **<font color="orange">片上可编程系统 (SOPC)</font>**：
    -   在单个FPGA芯片上集成处理器内核（软核或硬核）、内存、外设和自定义逻辑，构成一个完整的系统。
    -   **代表**：Altera 的 **Nios II** 软核处理器，Xilinx 的 **MicroBlaze** 软核处理器。
3.  **<font color="orange">高速I/O接口控制器</font>**：
    -   FPGA集成了越来越多高速串行收发器 (Transceivers)，支持如 PCIe, 10G Ethernet, SATA 等高速接口标准。
4.  **<font color="orange">高性能DSP应用</font>**：
    -   现代FPGA内部集成了大量的专用DSP模块（通常是乘法器和累加器），非常适合进行高性能的数字信号处理，如视频编解码、雷达信号处理等。

---

## 第二部分：EDA 开发软件平台 (Quartus II)

<font color="orange">Quartus II</font> 是Altera公司（现Intel）为其PLD器件开发的集成设计环境 (IDE)。

### 1. Quartus II 主要特性

它是一个<font color="orange">全集成</font>的设计工具，涵盖了FPGA开发的整个流程。

-   **核心功能**：
    -   多种设计输入方法 (HDL, 原理图)
    -   逻辑综合
    -   布局与布线 (Place & Route)
    -   仿真 (功能仿真 & 时序仿真)
    -   时序与功耗分析
    -   器件编程
-   **高级功能**：
    -   **RTL Viewer**：综合结果的图形化显示工具，帮助理解综合后的电路结构。
    -   **SignalTap II**：嵌入式逻辑分析仪，无需外部设备即可在线调试FPGA内部信号。
    -   **MegaWizard**：IP核和宏功能的参数化配置向导。

### 2. Quartus II 设计流程 (Design Flow)

一个标准的PLD设计流程如下：

1.  **设计输入 (Design Entry)** ⌨️：使用VHDL/Verilog等硬件描述语言或原理图输入法来描述电路功能。
2.  **RTL 仿真 (功能仿真)** 🧪：在综合前验证设计逻辑的正确性，不考虑时序延迟。
3.  **综合 (Synthesis)** 🧩：将高级的HDL代码转换为由底层逻辑单元（如LUT、触发器）构成的网表。
4.  **布局布线 (Place & Route)** 🗺️：将综合后的逻辑单元具体地放置到FPGA芯片的物理位置上，并连接它们之间的线路。
5.  **时序分析 (Timing Analysis)** ⏱️：分析布局布线后电路的实际延迟，检查是否满足时钟频率等时序约束。
6.  **门级仿真 (时序仿真)** ⏳：包含实际延迟信息的仿真，验证电路在目标器件上能否正常工作。
7.  **编程与调试 (Programming & Debugging)** 📥：生成编程文件，下载到FPGA芯片中，并在硬件上进行测试和调试。

### 3. Quartus II 项目管理

-   **项目 (Project)**：Quartus II 中管理一个设计所需的所有文件的集合。
-   **关键文件**：
    -   `.qpf` (Quartus Project File)：项目文件，记录项目信息。
    -   `.qsf` (Quartus Settings File)：设置文件，包含引脚分配、时序约束、器件型号等所有项目设置。
-   **项目导航器 (Project Navigator)**：
    -   <font color="orange">Hierarchy</font> 标签页：显示设计的层次结构。
    -   <font color="orange">Files</font> 标签页：显示项目包含的所有文件。
    -   <font color="orange">Design Units</font> 标签页：显示设计中实例化的每个单元。

### 4. 设计输入方法

Quartus II 支持多种设计输入方式，并且<font color="orange">允许混合使用</font>。

-   **文本输入 (HDL)**：
    -   Verilog (.v)
    -   VHDL (.vhd)
    -   AHDL (.tdf, Altera自家语言)
-   **图形输入**：
    -   原理图输入 (.bdf)
-   **使用宏功能/IP核**：
    -   通过 **MegaWizard Plug-In Manager** 可方便地生成和例化复杂的IP核，如PLL、RAM、FIFO等。

### 5. 编译 (Compilation)

编译是将设计代码转换成最终可下载到芯片的编程文件的过程，主要包括 **综合** 和 **布局布线 (Fitter)**。

-   **综合优化选项**：可以根据需求选择优化目标。
    -   **Speed** (速度优先)
    -   **Area** (面积优先)
    -   **Balanced** (平衡)
-   **布局布线优化**：
    -   **时序驱动编译**：编译器会尽力优化以满足用户的时序约束。
    -   **物理综合**：在布局布线后，根据实际的布线延迟再次对逻辑进行优化，以改善时序。
-   **编译报告 (Compilation Report)**：编译完成后生成的重要文档，包含了资源使用情况、时序分析结果、引脚分配、功耗估算等详细信息，是分析和优化设计的关键。

### 6. 仿真 (Simulation)

仿真是验证设计功能和时序正确性的重要手段。

-   **仿真类型**：
    1.  **功能仿真 (Functional Simulation)**：
        -   在综合之前进行，不考虑门延迟和线延迟。
        -   目的：快速验证设计的逻辑功能是否符合预期。
        -   模式：RTL级。
    2.  **时序仿真 (Timing Simulation)**：
        -   在布局布线之后进行，仿真网表包含了实际的延迟信息。
        -   目的：验证设计在目标器件和特定速度下，是否能满足时序要求。
        -   模式：门级 (Gate-Level)。

-   **激励文件**：
    -   在Quartus II中，通常使用 **Vector Waveform File (.vwf)** 来创建输入激励波形。可以方便地设置时钟、高低电平、计数序列等。

-   **功耗分析 (Power Analysis)** ⚡️：
    -   Quartus II 的仿真器可以根据信号的翻转率（toggle rate）来估算设计的功耗，帮助设计师进行低功耗设计。

---

## 📖 本章学习总结

本章我们系统地学习了EDA开发的硬件和软件平台，为后续的实践打下了坚实的基础。

1.  **硬件平台方面** 🧠：
    -   我们了解了PLD（可编程逻辑器件）从早期的PLA/PAL到现代CPLD/FPGA的完整发展脉络。
    -   核心在于掌握了两大主流器件 **CPLD** 和 **FPGA** 的根本区别：
        -   CPLD基于<font color="orange">乘积项</font>结构，非易失，适合逻辑控制。
        -   FPGA基于<font color="orange">查找表(LUT)</font>结构，易失性，资源丰富，适合复杂算法和数据处理。
    -   我们还探讨了FPGA相对于传统MCU的巨大优势，尤其是在<font color="orange">并行处理</font>和<font color="orange">硬件定制</font>方面。
    -   最后，我们展望了FPGA的四大发展趋势：IP核化、SOPC化、高速接口化和内置DSP化，这些都预示着FPGA将在更多领域发挥重要作用。

2.  **软件平台方面** 🖥️：
    -   我们熟悉了Altera Quartus II 这一强大的集成开发环境。
    -   重点掌握了标准的FPGA**设计全流程**：`设计输入` -> `功能仿真` -> `综合` -> `布局布线` -> `时序仿真` -> `下载调试`。
    -   我们学习了如何创建和管理一个Quartus II项目，以及如何使用不同的设计输入方法（特别是HDL和原理图）。
    -   理解了编译和仿真的核心概念，特别是**功能仿真**和**时序仿真**的差异与各自的目的，这是确保设计正确性的关键环节。

总之，硬件是舞台，软件是工具。只有深刻理解硬件的内部结构和特性，并熟练运用软件工具完成整个设计流程，我们才能真正驾驭FPGA，实现复杂而强大的数字系统设计。