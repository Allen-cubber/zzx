**第1章 51系列单片机的硬件结构**

本章主要介绍51单片机的基本组成和硬件结构，例题较少，我们关注一个引出性的应用实例。

*   **例题 (课件P4): 一个简单的单片机应用实例 (广告灯控制)**
    *   **题目描述:**
        设计一个简单的广告灯控制硬件电路，并编写程序实现流水灯效果。硬件连接如下图所示，8051的P0口连接8个LED（发光二极管），LED的阳极通过限流电阻接Vcc。
        
        (注：此图为根据课件P4电路示意图重绘的简化版，课件原图P0.0-P0.7分别连接VL0-VL7)
    *   **实现程序 (课件P4):**
        ```assembly
        实现程序：
              MOV A, #0FEH  ; A = 11111110B, P0.0输出低电平, VL0亮
        LP:   MOV P0, A     ; 将累加器A的内容送P0口
              LCALL DELAY   ; 调用延时子程序
              RL A          ; 累加器A的内容循环左移一位
              SJMP LP       ; 跳转到LP处，形成循环

        延时子程序：
        DELAY:
              ; (此处省略具体的延时指令，通常用多重循环实现)
              RET           ; 子程序返回
        ```
    *   **代码分析:**
        1.  `MOV A, #0FEH`: 将立即数`0FEH`（二进制为`11111110B`）送入累加器A。由于LED是共阳极接法，P0口输出低电平`0`时对应的LED会亮。所以`0FEH`使得与P0.0相连的LED (VL0) 点亮。
        2.  `LP: MOV P0, A`: 这是一个标号，表示循环的开始。将累加器A的内容输出到P0口，控制LED的亮灭状态。
        3.  `LCALL DELAY`: 调用名为`DELAY`的延时子程序。这个子程序的目的是产生一段时间的延时，使得人眼能够看清LED的亮灭变化。
        4.  `RL A`: `RL`是循环左移指令（Rotate Left）。它将累加器A中的各位向左移动一位，最高位D7移到最低位D0。例如，如果A是`11111110B`，执行`RL A`后，A变为`11111101B`，下一个亮的灯将是VL1。
        5.  `SJMP LP`: 短跳转指令，无条件跳转到标号`LP`处，形成一个无限循环，使LED不断地按顺序点亮，形成流水灯效果。
        6.  `DELAY: ... RET`: 延时子程序的框架。`...`代表实际的延时指令（通常是利用寄存器进行循环计数减操作），`RET`表示子程序执行完毕，返回到调用处（即`LCALL DELAY`的下一条指令`RL A`）。
    *   **这个例题的用意/教会我们什么:**
        *   **P0口作为输出口的使用:** 当P0口用作通用输出口时，由于其内部结构是漏极开路，通常需要外接上拉电阻。在此例中，LED的阳极接Vcc，P0口输出低电平点亮LED，相当于P0口作为灌电流输出。
        *   **基本程序流程控制:** 展示了如何使用循环 (`SJMP LP`) 和子程序调用 (`LCALL DELAY`) 来构建一个简单的控制程序。
        *   **位操作指令的应用:** `RL A` 指令巧妙地实现了流水灯灯位状态的改变。
        *   **软件延时的概念:** 了解在单片机程序中，为了控制事件发生的快慢，经常需要使用延时子程序。
        *   **立即数和端口操作:** `MOV A, #0FEH` 中的 `#` 表示立即数，`MOV P0, A` 是将累加器A的内容送到特殊功能寄存器P0（即P0端口）。

---

**第2章 指令系统**

本章详细介绍51单片机的指令系统，包括数据传送、算术运算、逻辑运算、控制转移和位操作等。

*   **例题1 (课件P50): 片内RAM传送指令举例 - 【例1】**
    *   **题目描述:** 将片内RAM 20H单元内容送A。
    *   **方法1答案:**
        ```assembly
        MOV A, 20H
        ```
    *   **方法2答案:**
        ```assembly
        MOV R0, #20H
        MOV A, @R0
        ```
    *   **代码分析:**
        *   方法1 (`MOV A, 20H`): 使用**直接寻址**方式。指令中的`20H`直接表示片内RAM的地址，CPU直接从这个地址单元读取数据到累加器A。
        *   方法2 (`MOV R0, #20H` 然后 `MOV A, @R0`): 使用**寄存器间接寻址**方式。首先将地址`20H`作为立即数送入寄存器R0（R0或R1可以作为间接寻址寄存器）。然后`MOV A, @R0`指令中的`@`符号表示R0中的内容是地址，CPU根据R0中的地址（即20H）去片内RAM中取数据到累加器A。
    *   **这个例题的用意/教会我们什么:**
        *   理解并区分直接寻址和寄存器间接寻址访问片内RAM数据的方式。
        *   掌握`MOV`指令在不同寻址方式下的使用。
        *   了解R0（和R1）可以作为间接寻址指针。

*   **例题2 (课件P50): 片内RAM传送指令举例 - 【例2】**
    *   **题目描述:** 将片内RAM 40H单元的内容送50H单元。
    *   **答案:**
        ```assembly
        MOV 50H, 40H  ; 课件写法，实际含义是 (50H) <- (40H)
        ```
    *   **代码分析:**
        课件中给出的 `MOV 50H, 40H` 是一种简化的表示。在标准的51指令集中，**不存在直接从一个RAM单元传送到另一个RAM单元的指令**。这条指令的实际执行过程通常是通过累加器A作为中介：
        ```assembly
        MOV A, 40H    ; 先将40H单元的内容读入累加器A
        MOV 50H, A    ; 再将累加器A的内容写入50H单元
        ```
        或者，如果使用寄存器作为中介（不常见于这种简单传送）：
        ```assembly
        MOV R1, 40H   ; 将40H单元内容送R1 (假设R1是通用寄存器，这里用R1举例，实际应为A)
        MOV 50H, R1   ; 将R1内容送50H单元
        ```
        **注意点:** 课件的写法 `MOV 50H, 40H` 是为了简洁表达操作意图，但实际编程时需要分解为通过累加器A中转的两条指令。
    *   **这个例题的用意/教会我们什么:**
        *   理解片内RAM单元之间数据传送需要通过累加器A作为中介。
        *   虽然课件写法简洁，但要明白其背后的实际指令操作。

*   **例题3 (课件P50): 片内RAM传送指令举例 - 【例3】**
    *   **题目描述:** 将20H开始的32个单元清0。
    *   **答案:**
        ```assembly
        MOV A, #00H    ; 将0送入累加器A，作为清零数据
        MOV R0, #20H   ; R0作为地址指针，指向起始地址20H
        MOV R7, #32    ; R7作为循环计数器，共32个单元
        LP1: MOV @R0, A  ; 通过R0间接寻址，将A中的0写入当前RAM单元
             INC R0     ; 地址指针R0加1，指向下一个RAM单元
             DJNZ R7, LP1 ; R7减1，若R7不为0，则跳转到LP1继续循环
             SJMP $      ; R7为0，循环结束，程序停在此处（原地踏步）
        ```
    *   **代码分析:**
        1.  `MOV A, #00H`: 准备好要写入的数据（0）。
        2.  `MOV R0, #20H`: 初始化地址指针R0，使其指向第一个要清零的单元（20H）。
        3.  `MOV R7, #32`: 初始化循环计数器R7，表示要操作32个单元。
        4.  `LP1: MOV @R0, A`: 将A中的0写入R0所指向的RAM单元。
        5.  `INC R0`: R0加1，为下一次操作准备好地址。
        6.  `DJNZ R7, LP1`: `DJNZ` (Decrement and Jump if Not Zero) 指令。先将R7的内容减1，然后判断R7是否为0。如果不为0，则跳转到标号`LP1`处继续执行循环；如果为0，则顺序执行下一条指令。
        7.  `SJMP $`: `$`表示当前指令地址。这条指令使程序在此处无限循环，通常用于程序主要任务完成后暂停或等待。
    *   **这个例题的用意/教会我们什么:**
        *   如何使用循环结构（`DJNZ`指令）来处理一片连续的内存区域。
        *   寄存器间接寻址（`@R0`）在批量数据处理中的高效应用。
        *   理解`INC`指令用于修改地址指针，`DJNZ`指令用于控制循环次数。

*   **例题4 (课件P51): 片外数据存储器传送指令 - 【例4】**
    *   **题目描述:** 将片外RAM 8000H单元的内容送片内RAM 60H。
    *   **答案:**
        ```assembly
        MOV DPTR, #8000H  ; 将片外RAM地址8000H送数据指针DPTR
        MOVX A, @DPTR     ; 从DPTR指向的片外RAM单元读取数据到A
        MOV 60H, A        ; 将A中的数据存入片内RAM 60H单元
        ```
    *   **代码分析:**
        1.  `MOV DPTR, #8000H`: `DPTR` (Data Pointer) 是一个16位的特殊功能寄存器，专门用于寻址64KB的片外数据存储器或程序存储器。此处将目标片外RAM地址`8000H`送入DPTR。
        2.  `MOVX A, @DPTR`: `MOVX` (Move External) 指令用于访问片外数据存储器。`@DPTR`表示以DPTR的内容作为地址。这条指令将地址为8000H的片外RAM单元的内容读入累加器A。
        3.  `MOV 60H, A`: 将累加器A中的数据（来自片外RAM）传送到片内RAM的60H单元，这里使用直接寻址。
    *   **这个例题的用意/教会我们什么:**
        *   如何使用`DPTR`作为16位地址指针访问片外RAM。
        *   `MOVX`指令的用法，特别是`MOVX A, @DPTR`（读片外RAM）。
        *   区分片内数据传送（`MOV`）和片外数据传送（`MOVX`）。
        *   片外数据与片内数据交换通常需要累加器A作为中介。

*   **例题5 (课件P52): 片外RAM或扩展I/O口传送指令举例 - 【例5】**
    *   **题目描述:** 将2040H端口的内容41H，读到片内RAM 20H单元中。
    *   **答案:**
        ```assembly
        MOV DPTR, #2040H  ; DPTR指向扩展I/O口地址2040H
        MOVX A, @DPTR     ; 从2040H端口读取数据到A
        MOV 20H, A        ; 将A中的数据（端口数据）存入片内RAM 20H
        ; 执行结果：(20H) = 41H (假设端口数据为41H)
        ```
    *   **代码分析:**
        与例题4类似，只是这里的`2040H`被视为一个扩展I/O端口的地址。51单片机的扩展I/O口与片外RAM统一编址，都使用`MOVX`指令访问。
    *   **这个例题的用意/教会我们什么:**
        *   扩展I/O端口与片外RAM使用相同的地址空间和访问指令（`MOVX`）。
        *   如何从扩展I/O端口读取数据。

*   **例题6 (课件P52): 片外RAM或扩展I/O口传送指令举例 - 【例6】**
    *   **题目描述:** 将片外RAM 2000H单元的内容，传送到片外RAM 3FFFH单元中。
    *   **答案:**
        ```assembly
        MOV DPTR, #2000H  ; DPTR指向源片外RAM地址
        MOVX A, @DPTR     ; 读取源单元内容到A
        MOV DPTR, #3FFFH  ; DPTR指向目标片外RAM地址
        MOVX @DPTR, A     ; 将A的内容写入目标单元
        ```
    *   **代码分析:**
        1.  `MOV DPTR, #2000H`: DPTR指向源地址。
        2.  `MOVX A, @DPTR`: 从源地址读取数据到累加器A。
        3.  `MOV DPTR, #3FFFH`: DPTR指向目标地址。
        4.  `MOVX @DPTR, A`: 将累加器A中的数据写入DPTR指向的目标片外RAM单元。
    *   **这个例题的用意/教会我们什么:**
        *   如何在两个不同的片外RAM单元之间传送数据（同样需要累加器A作为中介）。
        *   `MOVX @DPTR, A`（写片外RAM）指令的用法。

*   **例题7 (课件P53): 程序存储器数据传送指令(查表指令) - 【例7】远程查表**
    *   **题目描述:** 查平方表程序，求出20H单元内容的平方值，保存到21H单元。
        假设平方表存储在程序存储器中，表的内容为 `0,1,4,9,16,25,36,49,64,81` (即0到9的平方)。
    *   **答案:**
        ```assembly
        ...             ; (程序其他部分)
        MOV A, 20H        ; 读取20H单元的内容到A (假设内容为0-9之间)
        MOV DPTR, #TABLE  ; DPTR指向程序存储器中TABLE表的基地址
        MOVC A, @A+DPTR   ; 查表：A <- ((A)+(DPTR))
        MOV 21H, A        ; 将查表得到的平方值存入21H单元
        HERE: SJMP HERE
        TABLE: DB 0,1,4,9,16,25,36,49,64,81
        ```
    *   **代码分析:**
        1.  `MOV A, 20H`: 获取要查找平方的数（作为查表时的偏移量）。
        2.  `MOV DPTR, #TABLE`: `TABLE`是一个标号，代表程序存储器中数据表 `DB 0,1,...` 的起始地址。此指令将该起始地址送入DPTR。
        3.  `MOVC A, @A+DPTR`: 这是**变址寻址**指令，专门用于从程序存储器（ROM）中读取数据（通常是固定的表格数据）。`@A+DPTR` 表示将累加器A的内容（偏移量）与DPTR的内容（基地址）相加，得到的和作为实际要访问的程序存储器的地址。`MOVC` (Move Code) 指令从这个计算出的地址中取出字节数据，并送回累加器A。
        4.  `MOV 21H, A`: 将查找到的平方值（现在在A中）存入片内RAM的21H单元。
        5.  `TABLE: DB 0,1,4,9,16,25,36,49,64,81`: `DB` (Define Byte) 是一个伪指令，用于在程序存储器中定义字节数据。这里定义了一个从0的平方到9的平方的表。
    *   **这个例题的用意/教会我们什么:**
        *   如何使用`MOVC A, @A+DPTR`指令进行查表操作，从程序存储器中读取数据。
        *   `DPTR`作为基址寄存器，`A`作为变址寄存器（偏移量）。
        *   `DB`伪指令用于在程序存储器中定义数据表。
        *   远程查表适用于表格较大或位置较远的情况。

*   **例题8 (课件P54): 近程查表 - 【例8】**
    *   **题目描述:** (与例7类似，但使用`MOVC A, @A+PC`进行近程查表) 求出20H单元内容（假设为X）的(X+4)的平方值。
        (课件中表格是0-9的平方，指令 `ADD A,#4` 是为了让PC指向表格中正确的位置，假设X=0, 则A=0, PC指向ADD A,#4的下一条指令， MOVC A, @A+PC 就会从TABLE[A]取值, 这里的A应该是偏移量，所以需要PC先调整)
        课件原意似乎是：`20H`中的值为`N`，求`N`的平方，但表格从`MOVC`指令之后开始。
        为了与课件的指令对应，我们这样理解：假设要查表的数据为`Y` (0-7), `20H`中的内容是`Y-4`，程序先 `MOV A,20H`，再 `ADD A,#4` 得到`Y`。
        我们将题目简化为：设A中已有所求值的索引（0-9），查表得到其平方。
    *   **答案 (根据课件代码结构调整，更清晰地展示近程查表):**
        ```assembly
        ; 假设A中已有所求值的索引 (例如 A=2, 要求2的平方)
        ; 且MOVC指令紧随其后的是表格数据
        ; PC在执行MOVC A, @A+PC时，会先自动加1，指向下一条指令
        ; 所以，PC在计算地址时，是MOVC指令的下一条指令的地址

        ; 示例代码片段：
        ORG 0100H
        MOV A, #02H       ; 假设要查索引为2的值 (即2的平方)
        CALL LOOKUP_PC
        MOV R1, A         ; 结果存R1
        SJMP $

        LOOKUP_PC:
        MOVC A, @A+PC   ; PC是这条MOVC执行后，下一条指令的地址（即RET的地址）
                        ; A是偏移量
                        ; 假设A=0, 则访问RET后面的第一个DB
                        ; 这里PC是RET的地址，A是偏移，表格需紧跟RET
        RET             ; 注意：这个RET是表格的一部分，如果PC不调整，
                        ; 或者表格不是紧跟，会导致错误。
                        ; 正确的做法是表格紧跟MOVC, 或者用LJMP调整PC
        ; 为了演示MOVC A, @A+PC, 表格应该紧跟
        ; --- 更正课件的表格放置方式，使其更符合MOVC A, @A+PC的典型用法 ---

        ; 实际近程查表更常见的写法 (表格紧跟MOVC)
        ORG 0100H
        MOV A, 20H        ; 假设20H单元内容为X (0-9)
        ; ADD A, #OFFSET_TO_TABLE ; 如果MOVC和TABLE之间有其他指令，需要调整A
        ; 或者用AJMP/LJMP跳到查表函数，PC会是下一条指令
        
        ; 课件P54的程序结构，表格数据紧跟在SJMP $之后
        ; ORG 某个地址
        ; MOV A, 20H
        ; ADD A, #4       ; 假设20H中是N, (N+4)作为索引, 假设是0~7
        ; MOVC A, @A+PC   ; PC此时指向MOV 21H, A
                          ; 所以表格实际是从(PC_OF_MOV_21H_A + A)开始
        ; MOV 21H, A
        ; SJMP $
        ; TABLE: DB 0,1,4,9,16,25,36,49,64,81 ; 这里的TABLE地址与PC的计算有关

        ; --- 我们用一个更规范的近程查表例子，表格紧跟MOVC ---
        ORG 0100H
        MOV A, 20H      ; 取要查表的值 (例如A=2)
        CALL GET_SQUARE
        MOV 21H, A      ; 存储结果
        SJMP $

        GET_SQUARE:
        INC A           ; PC在MOVC时会指向下一条指令，MOVC的机器码是1字节
                        ; 如果表格从MOVC的下一字节开始，那么A作为偏移量不需要调整
                        ; 但MOVC A,@A+PC是PC+A, PC在执行时已指向下一指令.
                        ; 为了使A=0时取第一个, A=1取第二个, PC应指向TABLE的前一个地址
                        ; PC指向下一条指令 (即DB 0)
        MOVC A, @A+PC   ; A为0时, 取(PC+0)处的DB 0
                        ; A为1时, 取(PC+1)处的DB 1
        RET
        DB 0,1,4,9,16,25,36,49,64,81  ; 平方表，紧跟在查表指令之后
                                      ; 或者说在查表子程序的返回指令之后
        ```
    *   **代码分析 (针对规范的近程查表，表格紧跟查表指令或在子程序内):**
        1.  `MOVC A, @A+PC`: `PC` (Program Counter) 程序计数器，它总是指向下一条将要执行的指令的地址。当执行`MOVC A, @A+PC`时，PC的值是这条`MOVC`指令之后的那条指令的地址。累加器A中的值作为相对于当前PC值的偏移量。最终从 `(PC) + (A)` 这个程序存储器地址取数据。
        2.  表格的放置非常关键。为了使A中的索引值（如0, 1, 2...）能直接对应表格中的第0, 1, 2...个数据，表格数据（用`DB`定义）必须紧跟在`MOVC A, @A+PC`指令之后（或者在包含`MOVC`的子程序中，表格紧跟`RET`指令）。
        3.  课件P54的例子中，`TABLE: DB ...` 在 `SJMP $` 之后。当执行 `MOVC A, @A+PC` 时，`PC` 指向 `MOV 21H,A`。如果 `A` 中是索引 `i`，它会从 `(Address of MOV 21H,A) + i` 处开始取数据。这要求程序员精确计算 `TABLE` 的实际起始地址与 `MOV 21H,A` 的地址之间的偏移，或者 `ADD A, #offset` 来调整 `A`。
    *   **这个例题的用意/教会我们什么:**
        *   `MOVC A, @A+PC` 用于近程查表，适用于表格数据量不大且位于当前指令附近（2KB范围内，因为PC是16位，但通常用于更近的跳转）。
        *   理解PC在指令执行过程中的变化，以及它在变址寻址中的作用。
        *   近程查表时，表格数据的存放位置需要与PC的指向和A的偏移量精确配合。
        *   **易错点:** `MOVC A, @A+PC` 中PC的值是MOVC指令的下一条指令的地址。如果表格不是紧随其后，需要调整A的值或使用跳转来定位PC。

*   **例题9 (课件P57): 栈操作指令应用举例 - 【例9】**
    *   **题目描述:** 设SP=30H，将现场A和DPTR的内容进栈(保护现场)。已知A=12H，DPTR=3456H。
    *   **答案:**
        ```assembly
        MOV SP, #30H    ; 初始化堆栈指针SP (实际应用中通常在程序开始时设置)
        ; 假设 A=12H, DPH=34H, DPL=56H
        PUSH ACC        ; A的内容 (12H) 进栈。SP递增为31H，(31H) <- 12H
        PUSH DPL        ; DPTR的低字节DPL (56H) 进栈。SP递增为32H，(32H) <- 56H
        PUSH DPH        ; DPTR的高字节DPH (34H) 进栈。SP递增为33H，(33H) <- 34H
        ; 执行结果：SP=33H，(31H)=12H，(32H)=56H，(33H)=34H。
        ```
        课件图示（栈顶是高地址，栈底是低地址，SP总是指向栈顶元素）：
        初始SP=30H
        PUSH ACC (12H) -> SP=31H, (31H)=12H
        PUSH DPL (56H) -> SP=32H, (32H)=56H
        PUSH DPH (34H) -> SP=33H, (33H)=34H
        栈内情况：
        33H: 34H (DPH) <- SP 指向这里 (栈顶)
        32H: 56H (DPL)
        31H: 12H (ACC)
        30H: xx (栈底，原SP所指单元的下一个单元)
    *   **代码分析:**
        1.  `MOV SP, #30H`: 设置堆栈指针SP的初始值。51单片机的堆栈是向高地址方向增长的。`SP` 指向的是栈顶**已存有数据**的单元。
        2.  `PUSH ACC`: `PUSH` 指令执行时，首先将SP的内容加1（`SP <- SP+1`），然后将指定寄存器（这里是ACC）的内容存入SP所指向的RAM单元（`(SP) <- (ACC)`）。
        3.  `PUSH DPL` 和 `PUSH DPH`: 同样地，先SP+1，再存数据。由于DPTR是16位寄存器，通常将其高字节DPH和低字节DPL分开入栈。
    *   **这个例题的用意/教会我们什么:**
        *   理解堆栈指针`SP`的作用和51单片机堆栈向高地址增长的特性。
        *   `PUSH`指令的操作过程：先增加SP，后存数据。
        *   如何使用`PUSH`指令保护寄存器（如A, DPL, DPH）的现场，常用于子程序调用前或中断响应时。
        *   16位寄存器DPTR需要分两次（DPH, DPL）入栈。

*   **例题10 (课件P57): 栈操作指令应用举例 - 【例10】**
    *   **题目描述:** 将上例进栈内容出栈(恢复现场)。SP=33H, (31H)=12H, (32H)=56H, (33H)=34H。
    *   **答案:**
        ```assembly
        ; 假设当前 SP=33H, (33H)=34H, (32H)=56H, (31H)=12H
        POP DPH         ; 从(SP)即33H单元取出数据(34H)到DPH。SP递减为32H。
        POP DPL         ; 从(SP)即32H单元取出数据(56H)到DPL。SP递减为31H。
        POP ACC         ; 从(SP)即31H单元取出数据(12H)到ACC。SP递减为30H。
        ; 执行结果：A=12H，DPTR=3456H，SP=30H。
        ```
    *   **代码分析:**
        1.  `POP DPH`: `POP`指令执行时，首先将SP所指向的RAM单元的内容取出到指定寄存器（这里是DPH），然后将SP的内容减1（`(DPH) <- (SP)`, `SP <- SP-1`）。
        2.  `POP DPL` 和 `POP ACC`: 类似操作。
        3.  **注意出栈顺序:** 出栈的顺序必须与进栈的顺序相反，才能正确恢复寄存器的原始值。例9中进栈顺序是ACC, DPL, DPH，所以例10出栈顺序是DPH, DPL, ACC。
    *   **这个例题的用意/教会我们什么:**
        *   `POP`指令的操作过程：先取数据，后减少SP。
        *   如何使用`POP`指令恢复先前保护的寄存器现场，常用于子程序返回前或中断返回前。
        *   强调出栈顺序与进栈顺序相反的重要性。

*   **例题11 (课件P58): 加法指令 - 【例11】**
    *   **题目描述:** 已知A=B5H，R1=96H，执行指令：`ADD A, R1`
    *   **运算过程:**
        A = B5H = `1011 0101B`
        R1 = 96H = `1001 0110B`
        ```
          1011 0101  (B5H)
        + 1001 0110  (96H)
        -----------------
        1 0100 1011  (结果4BH, 进位Cy=1)
        ```
        低四位: `0101 + 0110 = 1011B` (0BH), 无半进位AC=0。
        高四位: `1011 + 1001 = 10100B` (加上低四位无进位), D7位产生进位，所以Cy=1。
        符号位判断溢出OV：操作数B5H (负数)，96H (负数)，结果4BH (正数)。两个负数相加得到正数，发生溢出，OV=1。
        (课件解释：A为B5H(-75)，R1为96H(-106)。B5H+96H = 4BH (+75)。两个负数相加得到正数，溢出。)
        P (奇偶校验位): 结果A=4BH=`0100 1011B`，有4个1（偶数个1），所以P=0。
    *   **答案:**
        运算结果：A = 4BH
        标志位：Cy = 1, AC = 0, OV = 1, P = 0
    *   **代码分析:**
        `ADD A, R1`: 将累加器A的内容与寄存器R1的内容相加，结果存回累加器A。
        这条指令会影响PSW（程序状态字）中的标志位：
        *   `Cy` (Carry Flag): D7位（最高位）是否产生进位。
        *   `AC` (Auxiliary Carry Flag): D3位向D4位是否产生进位（半进位），用于BCD码调整。
        *   `OV` (Overflow Flag): 带符号数运算是否溢出。当两个正数相加结果为负，或两个负数相加结果为正时，OV=1。
        *   `P` (Parity Flag): 累加器A中1的个数的奇偶性。奇数个1则P=1，偶数个1则P=0。
    *   **这个例题的用意/教会我们什么:**
        *   `ADD`指令的执行方式和结果存储。
        *   理解加法运算如何影响PSW中的Cy, AC, OV, P等标志位。
        *   如何判断半进位AC、全进位Cy、溢出OV。
        *   如何计算奇偶校验位P。

... (后续例题将按此格式继续)

*   **例题20 (课件P74): 循环判终指令 - 【例20】**
    *   **题目描述:** 设计一个延时1ms的子程序，设时钟频率为12MHz (一个机器周期为1μs)。
    *   **答案 (程序如下):**
        ```assembly
        ; 指令的周期数
        DELAY: MOV R7, #0FFH   ; 1  (实际应为 #249 或 #250 附近, 0FFH太大)
                                ; 课件用0FFH是为了简化，凑近似值。
                                ; 假设用250 (0FAH)
                                ; MOV R7, #250
        LOOP:  NOP             ; 1
               NOP             ; 1
               DJNZ R7, LOOP   ; 2
               RET             ; 2
        ```
    *   **代码分析与延时计算:**
        一个机器周期 = 12 / 时钟频率 (MHz) = 12 / 12MHz = 1μs。
        课件中循环体是 `NOP (1) + NOP (1) + DJNZ (2) = 4μs`。
        `MOV R7, #0FFH` (0FFH = 255)
        总延时 = `MOV R7`周期 + (循环体周期 × R7初值) + `RET`周期
        $T_{delay} = 1\mu s + (1\mu s + 1\mu s + 2\mu s) \times 255 + 2\mu s$
        $T_{delay} = 1 + (4 \times 255) + 2 = 1 + 1020 + 2 = 1023\mu s \approx 1ms$

        如果更精确地计算R7初值N使其为1000us (1ms):
        $1 + (1+1+2) \times N + 2 = 1000$
        $3 + 4N = 1000$
        $4N = 997$
        $N = 997 / 4 = 249.25$
        取 $N=249$ (0F9H): $T = 3 + 4 \times 249 = 3 + 996 = 999 \mu s$
        取 $N=250$ (0FAH): $T = 3 + 4 \times 250 = 3 + 1000 = 1003 \mu s$
        所以R7的初值设为249或250更接近1ms。课件用255 (0FFH) 是一个粗略的近似。
    *   **这个例题的用意/教会我们什么:**
        *   如何使用循环结构和`NOP`指令来构造软件延时子程序。
        *   理解指令周期数在延时计算中的作用。
        *   如何根据所需的延时时间倒推循环次数和寄存器初值。
        *   `DJNZ`指令在延时程序中的核心作用。
        *   **注意点:** 实际的延时值需要根据具体的指令周期数精确计算。NOP指令占用1个机器周期。

---

**第3章 定时器/计数器的应用**

*   **例题 【例3-1】 (课件P107): 利用T0在P1.0产生25Hz的方波，设fosc=12MHz。 (查询方式)**
    *   **题目分析:**
        *   方波频率25Hz，则周期 $T = 1/25Hz = 40ms$。
        *   方波高电平和低电平各占一半时间，所以每次定时时间为 $40ms / 2 = 20ms$。
        *   $f_{osc} = 12MHz$，则一个机器周期 $T_{cy} = 12 / f_{osc} = 12 / 12MHz = 1\mu s$。
        *   定时器计数脉冲频率为 $f_{osc}/12 = 1MHz$，即每个计数脉冲周期为 $1\mu s$。
        *   设T0工作于方式1（16位定时器）。
        *   定时 $20ms = 20000\mu s$。
        *   需要计数值 $N = 20000\mu s / 1\mu s = 20000$ 个机器周期。
        *   16位定时器最大计数值为 $2^{16} = 65536$。
        *   计数初值X计算公式: $\boxed{(2^{16} - X) \times T_{cy} = \text{定时时间}}$
            $65536 - X = \text{定时时间} / T_{cy} = 20000\mu s / 1\mu s = 20000$
            $X = 65536 - 20000 = 45536$
            $45536_{10} = B1E0H_{16}$
        *   所以 TH0 = B1H, TL0 = E0H。
    *   **查询方式程序如下 (课件P107):**
        ```assembly
        ORG 0000H
        MOV TMOD, #01H    ; T0工作于方式1 (16位定时)
        MOV TH0, #0B1H    ; 装载计数初值高字节
        MOV TL0, #0E0H    ; 装载计数初值低字节
        SETB TR0          ; 启动定时器T0
        SETB P1.0         ; P1.0初始置高电平 (也可置低)
        LOOP: JNB TF0, LOOP   ; 查询TF0标志位，TF0=0则在此等待
               CLR TF0          ; TF0=1 (溢出)，清除TF0标志
               CPL P1.0         ; P1.0口电平取反，产生方波
               MOV TH0, #0B1H    ; 重新装载初值 (方式1需要手动重装)
               MOV TL0, #0E0H
        ;      SETB TR0          ; TR0在方式1溢出后会自动清零吗？不会，所以不需要重开
                                ; 除非之前用CLR TR0关过。TF0清零后，计数器会从0继续。
                                ; 要想从初值开始，必须重装初值。
               SJMP LOOP        ; 继续循环产生方波
        END
        ```
    *   **代码分析:**
        1.  `MOV TMOD, #01H`: 设置TMOD寄存器，选择定时器0工作在方式1 (M1=0, M0=1, C/T=0, GATE=0)。
        2.  `MOV TH0, #0B1H` 和 `MOV TL0, #0E0H`: 将计算得到的初值B1E0H分别装入TH0和TL0。
        3.  `SETB TR0`: 置位TCON寄存器中的TR0位，启动定时器T0开始计数。
        4.  `SETB P1.0`: 初始化P1.0端口为高电平（或低电平，取决于希望方波的起始状态）。
        5.  `LOOP: JNB TF0, LOOP`: `JNB` (Jump if No Bit) 指令。查询TCON寄存器中的TF0（定时器0溢出标志位）。如果TF0为0（未溢出），则跳转回`LOOP`原地等待。如果TF0为1（已溢出），则顺序执行下一条指令。
        6.  `CLR TF0`: 当TF0=1时，表示定时时间到。在查询方式下，**必须用软件清除TF0标志**，为下一次定时做准备。
        7.  `CPL P1.0`: `CPL` (Complement) 指令，将P1.0口的电平取反，从而产生方波的跳变。
        8.  `MOV TH0, #0B1H` 和 `MOV TL0, #0E0H`: 定时器在方式1下，溢出后TH0和TL0会从0000H开始重新计数。为了保持每次定时20ms，**必须重新装载初值**。
        9.  `SJMP LOOP`: 跳转回`LOOP`，开始下一次查询和电平翻转。
    *   **这个例题的用意/教会我们什么:**
        *   如何计算定时器方式1的计数初值以获得特定的定时时间。
        *   定时器TMOD寄存器的设置方法。
        *   如何启动定时器 (`SETB TR0`)。
        *   查询方式下如何检测定时器溢出 (`JNB TF0, $`) 以及如何清除溢出标志 (`CLR TF0`)。
        *   在方式1下，每次溢出后需要手动重装计数初值。
        *   如何利用定时器和端口操作产生一定频率的方波信号。
        *   **易错点:** 查询方式下忘记清除TF0标志，或忘记重装初值（方式1）。

*   **例题 【例3-1】 (课件P108): 利用T0在P1.0产生25Hz的方波，设fosc=12MHz。 (中断方式)**
    *   **题目分析:** 与查询方式相同，定时20ms，初值TH0=B1H, TL0=E0H。
    *   **中断方式程序如下 (课件P108):**
        ```assembly
        ORG 0000H
        LJMP MAIN
        ORG 000BH         ; 定时器T0的中断向量入口地址
        AJMP T0INT        ; 跳转到T0中断服务程序
        ORG 0030H         ; 主程序起始地址
        MAIN: MOV TMOD, #01H    ; T0工作于方式1
              MOV TH0, #0B1H    ; 装载初值
              MOV TL0, #0E0H
              MOV IE, #82H      ; 开中断：EA=1, ET0=1 (1000 0010B)
              SETB TR0          ; 启动定时器T0
              SETB P1.0         ; P1.0初始置高
        SLOOP:SJMP SLOOP        ; 主程序在此等待中断 (或执行其他任务)

        T0INT: CPL P1.0         ; 中断服务程序：P1.0取反
               MOV TH0, #0B1H    ; 重装初值
               MOV TL0, #0E0H
               RETI             ; 中断返回
        END
        ```
    *   **代码分析:**
        1.  `ORG 0000H, LJMP MAIN`: 程序从0000H开始，跳转到主程序`MAIN`。
        2.  `ORG 000BH, AJMP T0INT`: `000BH`是定时器T0的中断服务程序入口地址（中断向量）。当T0溢出并产生中断时，CPU会自动跳转到这里。`AJMP T0INT`再跳转到实际的中断服务程序`T0INT`。
        3.  `MAIN`程序块:
            *   初始化TMOD, TH0, TL0与查询方式相同。
            *   `MOV IE, #82H`: 设置中断允许寄存器IE。`82H` (二进制`10000010B`) 表示 `EA=1` (CPU总中断允许) 和 `ET0=1` (定时器0中断允许)。
            *   `SETB TR0`: 启动T0。
            *   `SETB P1.0`: 初始化P1.0。
            *   `SLOOP: SJMP SLOOP`: 主程序在此循环等待，当T0中断发生时，CPU会自动处理中断。
        4.  `T0INT`中断服务程序块:
            *   `CPL P1.0`: P1.0口电平取反。
            *   `MOV TH0, #0B1H`, `MOV TL0, #0E0H`: 重装初值。在中断方式下，TF0标志由硬件自动清除，但方式1仍需手动重装初值。
            *   `RETI`: 中断返回指令。CPU从中断服务程序返回到主程序被中断的地方继续执行（此处是`SLOOP`）。
    *   **这个例题的用意/教会我们什么:**
        *   中断方式下定时器产生方波的基本流程。
        *   中断向量表的概念和用法 (`ORG 000BH`)。
        *   中断允许寄存器IE的设置 (`EA`和各中断源允许位如`ET0`)。
        *   中断服务程序的编写结构，特别是结尾必须用`RETI`。
        *   中断方式下，TF0由硬件自动清零，但方式1仍需软件重装初值。
        *   主程序和中断服务程序的分离，主程序可以执行其他任务，定时由中断自动处理。
        *   **注意点:** 中断服务程序应尽可能简短高效，不要包含延时或复杂循环。

... (后续章节例题若有，将继续按此格式展开)

**第6章 并行总线扩展技术**

*   **例题 【例6-1】 (课件P169): 扩展4KB EPROM的8031系统。**
    *   **题目描述:**
        使用一片2732 (4KB EPROM) 为8031扩展程序存储器。画出连接图并确定芯片地址范围。
        8031的P0口作地址/数据复用总线 (AD0-AD7)，P2口作高8位地址总线 (A8-A15)。
        ALE信号用于锁存P0口送出的低8位地址 (A0-A7) 到地址锁存器 (如74LS373)。
        PSEN信号作为片外EPROM的读选通信号。
        ![](https://i.imgur.com/c2YwB0p.png)
        (课件P169图示简化，2732有12根地址线A0-A11，对应 $2^{12}=4096$ 即4KB)
        8031引脚连接：
        *   P0.0-P0.7 (AD0-AD7) -> 74LS373的D0-D7输入，74LS373的Q0-Q7输出 -> 2732的A0-A7 (低8位地址)
        *   P0.0-P0.7 (AD0-AD7) -> 2732的D0-D7 (数据线)
        *   ALE -> 74LS373的G (或LE) 引脚 (锁存控制)
        *   P2.0-P2.3 -> 2732的A8-A11 (高4位地址，因为2732是4KB，需要A0-A11共12根地址线)
        *   PSEN -> 2732的CE非 (片选) 和 OE非 (输出使能) 通常会通过逻辑门组合或直接连接（如CE非接地，PSEN接OE非）。课件图中PSEN直接或间接控制CE非和OE非。
        *   EA引脚必须接地，强制8031从片外ROM启动。
    *   **芯片地址范围确定 (课件P169):**
        2732是4KB EPROM，需要12条地址线 (A0-A11)。
        *   A0-A7 由P0口经74LS373锁存后提供。
        *   A8-A11 由P2.0-P2.3提供。
        *   P2.4-P2.7 未用于片选2732（在本例中，假设只扩展这一片4KB的EPROM，所以这些高位地址线可以认为是“无关位”或者用于未来的扩展片选）。
        如果P2.4-P2.7均取0，则8031能访问的地址范围由A0-A11决定，即`0000H`到`0FFFH`（共4KB）。
        课件P169图示：
        P2.7 P2.6 P2.5 P2.4 | P2.3 P2.2 P2.1 P2.0 (A11 A10 A9 A8) | A7 ... A0
        `0   x   x   x`   | `0    0    0    0`       至 `1    1    1    1`  | `0...0` 至 `1...1`
        如果我们将“无关位” (P2.7-P2.4) 都设为0，则芯片基本地址范围为：
        `0000 0000 0000 0000B` 到 `0000 1111 1111 1111B`
        即 $\boxed{0000H \sim 0FFFH}$。这就是2732 EPROM在8031系统中的地址空间。
    *   **这个例题的用意/教会我们什么:**
        *   8031（无片内ROM）系统扩展外部程序存储器（EPROM）的基本连接方法。
        *   P0口作为地址/数据复用总线，需要外部地址锁存器（如74LS373）和ALE信号配合。
        *   P2口作为高8位地址总线。
        *   PSEN信号用于读取外部程序存储器。
        *   EA引脚在扩展外部程序存储器时的作用（必须接地）。
        *   如何根据存储芯片的容量和所用单片机地址线来确定其在系统中的地址范围。
        *   “无关位”的概念：未参与片选译码的地址线。
